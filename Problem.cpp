/*
 * Problem.cpp
 */

#include "Problem.hpp"
#include "Dummy.hpp"
#include "Exceptions/Headers/CoioteException.hpp"
#include <fstream>
#include <sstream>

using namespace std;

/*
 * get inputPath and outputPath from command line
 */
Problem::Problem(string inputPath, string outputPath) {
    this->inputPath = inputPath;
    this->outputPath = outputPath;
    load();
    // TODO: i parametri sottostanti andrebbero riempiti mentre si legge il file di input (magari direttamente nella funzione "load"?)
    cellsNumber = 0;
    peopleTypes = 0;
    timePeriods = 0;
    costs = new CostMatrix(cellsNumber, peopleTypes, timePeriods);
    people = new PeopleMatrix(timePeriods, peopleTypes, cellsNumber);
}

/*
 * The following constructor is temporary, it is used for testing the program before the loader implemmentation,
 * where the parameters are hard-coded and the data is generated by the Dummy class functions.
 */
Problem::Problem(int cellsNumber, int peopleTypes, int timePeriods) {
    this->cellsNumber = cellsNumber;
    this->peopleTypes = peopleTypes;
    this->timePeriods = timePeriods;
    costs = new CostMatrix(cellsNumber, peopleTypes, timePeriods);
    people = new PeopleMatrix(timePeriods, peopleTypes, cellsNumber);
    dummyLoad();

}

/*
 * load Input file. By loading the inputFiles it also reads problem parameters such as cellsNumber, etc., which are
 * needed by the constructor Problem() to allocate it's fields. (Maybe it could become private and called by the
 * constructor itself?)
 */
void Problem::load() {
    string line; // contains a line of the Input file
    string word; // contains a single word (into a line)

    // open Input file
    ifstream inputFileStream(Problem::inputPath.c_str());

    if (!inputFileStream.is_open()) {
        // todo lancia eccezione
        throw new CoioteException("Error: unable to open " + Problem::inputPath);
    }

    /*
     * read first line: cellsNumber periodsNumber peopleTypes
     */
    getline(inputFileStream, line);
    istringstream inputStringStream(line);

    inputStringStream >> word;

    return;
}

/*
 * Just a temporary method that fills the problem data with randomly generated data
 */
void Problem::dummyLoad() {
    cout << "dummyLoad() called\n";
    int MAX_TASKS = 50;
    Dummy::fillCostMatrix(costs, cellsNumber, timePeriods, peopleTypes);
    Dummy::fillPeopleMatrix(people, cellsNumber, timePeriods, peopleTypes, MAX_TASKS, MAX_TASKS * 2);
    totalTasks = Dummy::allocateAndFillTasksArray(cellsNumber, MAX_TASKS);

}

/*
 * generate initial solution and solve the problemi with population-based simulated annealing
 * Parameters meaning explained in-line
 */
int Problem::solve(int populationDimension, int eliteDimension) {
    cout << "solve() called, attempting to solve the problem\n";

    Solution *initialSolution;
    vector<int> eliteIndexes;                       //The elite is an vector of the indexes of the best solution
    bool flag;                                      //Flag used to distinguish solutions in the elite
    int invariantCellsOfNeighborhood = 5;           //This is the number of cells invariant in the generation of neighborhood
    int stepsPerWave = 2;                           //A step means a decrement of temperature
    int stableWaves = 0;                            //Parameter necessary to stop the algorithm
    int maxStableWaves = 10;                        //Parameter necessary to stop the algorithm

    initialSolution->generateInitialSolution(totalTasks, cellsNumber, people->getPeopleMatrix(), costs, cellsNumber);
    currentBestSolution = initialSolution;          //at the beginning the best solution is the initial solution
    /*
     * below a population of instances of standard Simulation Annealing is declared, each one with his current solution stored inside,
     * provided in the first wave of the algorithm by making a copy (with copy-constructor) of the initial solution generated above;
     */
    SimulatedAnnealing *simAnnealings = new SimulatedAnnealing[populationDimension]();

    //First wave is performed separatly to be able to assign each instance of Simulated Annealing his own starting solution
    for (int i = 0; i < populationDimension; i++) {
        simAnnealings[i].setInitialSolution(new Solution(*initialSolution));
        simAnnealings[i].resetTemperature();                                                //temperature set to max
        simAnnealings[i].run(invariantCellsOfNeighborhood, totalTasks, cellsNumber,
                             people->getPeopleMatrix(), costs, cellsNumber, stepsPerWave);
    }
    updateElite(simAnnealings, populationDimension, eliteIndexes, eliteDimension);
    //end of first wave, the elite contains the best solutions up to now

    //successive waves, the cycle is stopped when the best solution has not been updated for "maxStableWaves" consecutive waves
    while (stableWaves < maxStableWaves) {
        for (int i = 0; i < populationDimension; i++) {
            flag = false;
            for (int j = 0; j < eliteDimension; j++)
                if (i == eliteIndexes[j]) flag = 1;       //checking if this solution is part of the elite

            if (flag) {     //if the Solution belongs to the elite the Simulated Annealing simply resume from the point it left
                simAnnealings[i].run(invariantCellsOfNeighborhood, totalTasks, cellsNumber,
                                     people->getPeopleMatrix(), costs, cellsNumber, stepsPerWave);
            } else {          //if the Solution doesn't belongs to the elite it restart at max temperatur with currentBestSolution as starting Solution
                simAnnealings[i].setInitialSolution(new Solution(*currentBestSolution));
                simAnnealings[i].resetTemperature();
                simAnnealings[i].run(invariantCellsOfNeighborhood, totalTasks, cellsNumber,
                                     people->getPeopleMatrix(), costs, cellsNumber, stepsPerWave);
            }
        }//end of wave;
        if (updateElite(simAnnealings, populationDimension, eliteIndexes, eliteDimension)) {
            stableWaves = 0;
        } else stableWaves++;
    }
    currentBestSolution->print(1);
    return 0;
}

/*
 *      This method updates the elite with the current best solutions found after a new wave of the algorithm.
 *      It eventually also update the general current Best Solution of the Problem
 *
 *      Parameters:
 *      simAnnealingInstances -> this parameter is required to have access to all current solutions in the population and their evaluations
 *      elite -> this is a vector storing the indexes in simAnnealingInstances of the members of the elite.
 *      using std::vector for a better implementation of insertion sort
 *
 *      This method return true if the best solution of the problem has been updated. False otherwise
 */
bool Problem::updateElite(SimulatedAnnealing *simAnnealingInstances, int simAnnealingDimension, vector<int> elite,
                          int eliteDim) {
    vector<int>::iterator it;
    bool flag = 0;
    for (int i = 0; i < simAnnealingDimension; i++) {
        it = elite.begin(); //if elite is empty elite.begin() == elite.end()
        while ((it <= elite.end()) && (simAnnealingInstances[i].getCurrSolution()->evaluate() <
                                       simAnnealingInstances[*it].getCurrSolution()->evaluate()))
            it++;
        //con && se l'iteratore esce dalla dimensine massima di elite, non viene effettuato il secondo controllo
        elite.insert(it, i);
        if (elite.size() > eliteDim)
            elite.pop_back();           //riporta la dimensione dell'elite a quella corretta
    }
    //checking if current best solution has to be updated.
    if (simAnnealingInstances[elite[0]].getCurrSolution()->evaluate() < currentBestSolution->evaluate()) {
        currentBestSolution = simAnnealingInstances[elite[0]].getCurrSolution();
        flag = true;
    }
    return flag;
}

Solution *Problem::getBestSolution() {
    return currentBestSolution;
}


